/**
* References available in 'README.md'
*/

import java.util.function.BinaryOperator;

/**
* Class for the SRPN calculator. 
*
* Following references [1] and [2], I decided to approach the problem
* using a stack as a custom data structure, using a class to hold the methods and variables.
* For the numeric calculations, I created a separate class to hold the numeric methods.
*/



public class SRPN {

    
    private Stack stack; // Holds methods for stack operations
    private NumericOperations operations; // Holds methods for numeric operations
    private  boolean inComment; // Boolean to check if we are in a comment

    // Constructor
    public SRPN() {
        inComment = false; // We construct the class ensuring we are outside of comment mode
        stack = new Stack(23); // Stack size is 23, matching our source SRPN program
        operations = new NumericOperations();
    }

    // Helper method to apply a Peek-Pop-Push operation
    public int applyOperation(BinaryOperator<Integer> expression) {
        int a = stack.peekAndPop();
        int b = stack.peekAndPop();
        int result = expression.apply(b, a);
        stack.push(result);
        return result;
    }

    // Helper method to check for stack underflow, common to most mathematical methods
    private Boolean isStackUnderflow() {
        if (stack.getStackHead() < 1) { // We need at least two numbers on the stack to perform an operation
            stack.handleError("underflow");
            return true;
        }
        return false;
    }

    public void addNumbers() {
        if (isStackUnderflow()) {
            return;
        }
        int a = stack.peekAndPop();
        int b = stack.peekAndPop();
        int result = operations.add(b, a);
        stack.push(result);
    }

    public void deleteNumbers() {
        if (isStackUnderflow()) {
            return;
        } 
        int a = stack.peekAndPop();
        int b = stack.peekAndPop();
        int result = operations.subtract(b, a);
        stack.push(result);
    }

    public void multiplyNumbers() {
        if (isStackUnderflow()) {
            return;
        }
        int a = stack.peekAndPop();
        int b = stack.peekAndPop();
        int result = operations.multiply(b, a);
        stack.push(result);
    }

    public void divideNumbers() {
        if (isStackUnderflow()) {
            return;
        }
        int a = stack.peekAndPop();
        int b = stack.peekAndPop();

        // Use try catch to catch division by zero and handle accordingly
        try {
            int result = operations.divide(b, a);
            stack.push(result);
        } catch (ArithmeticException e) {
            System.out.println(e.getMessage());
            stack.push(b); // Push back the values to the stack
            stack.push(a);
        }
    }

    public int modulusNumbers() {
        if (isStackUnderflow()) {
            return Integer.MIN_VALUE;
        }
        return applyOperation((b, a) -> b % a);
    }

    public void powerNumbers() {
        if (isStackUnderflow()) {
            return;
        }
        int a = stack.peekAndPop();
        int b = stack.peekAndPop();
        int result = operations.power(b, a);

        stack.push(result);
    }

    public String displayStack() {
        return stack.printStack();
    }
    /**
    * The numbers generated by the source SRPN appear to be legacy C libarary rand() calls
    * with a srand() seed of 1. Reference [3]
    */
    public void random() {
        int randomNum = operations.rand();
        stack.push(randomNum);
    }

    // Process each char in our input string
    public void processCommand(String s) {
        /**
        * Create a string builder to hold numbers we encounter, convert to int and push
        * to stack thereafter
        */
        StringBuilder num = new StringBuilder();

        for (int i = 0; i < s.length(); i++) {

            Boolean suppressOutput = false; // Only suppress output for compound operators

            // Character at the current index
            char c = s.charAt(i);

            // Handle comments
            if (inComment) {
                if (c == '#') {
                    inComment = false;
                    continue;
                } else {
                    continue;
                }
            }

            /**
            * Given more time, I would like to refactor this using a tree data structure
            * to improve operand order of precedence. Reference [5]
            */

            // Build a string of numbers as we encounter them and handle negative numbers correctly
            if (Character.isDigit(c)) {
                num.append(c);
                continue;
            } else if (i + 1 < s.length() && c == '-' && Character.isDigit(s.charAt(i + 1))) { // We need to catch the situation where we are inputting a negative number
                num.append(c);
                continue;
            } else if (num.length() > 0) {
                // Push our number to the stack, parsing the string as an integer
                stack.push(Integer.parseInt(num.toString()));
                num.setLength(0);
            }

            // compound operators, e.g. "+=" seem to peek the stack.
            if (i + 1 < s.length() && "+-*/%^".indexOf(s.charAt(i)) != -1 && "=".indexOf(s.charAt(i + 1)) != -1) {
                System.out.println(stack.peek()); // Display top of the stack
            }
            // Suppress output for the "=" operator when there is a compound operator before it
            if (i > 0 && "+-*/%^".indexOf(s.charAt(i - 1)) != -1 && s.charAt(i) == '=') {
                suppressOutput = true;
            }

            // Process operators and other commands
            switch (c) {
                case '#':
                    inComment = true;
                    break;
                case '+':
                    addNumbers();
                    break;
                case '-':
                    deleteNumbers();
                    break;
                case '*':
                    multiplyNumbers();
                    break;
                case '/':
                    divideNumbers();
                    break;
                case '%':
                    modulusNumbers();
                    break;
                case '=':
                    if (!suppressOutput) { // Handle suppressed output for compound operators
                        System.out.println(stack.peek());
                    } else if (suppressOutput) {
                    }
                    break;
                case 'd':
                    System.out.println(displayStack()); // Display the entire stack
                    break;
                case 'r':
                    random(); // Generate a psuedo-random number
                    break;
                case '^':
                    powerNumbers();
                    break;
                case ' ': // Ignore spaces
                    break;
                default:
                    System.out.println("Unrecognised operator or operand  \"" + c + "\".");
                    break;
            }

        }
        // catch any remaining numbers, typically entered as the last or only input
        if (num.length() > 0) {
            stack.push(Integer.parseInt(num.toString()));
        }
    }
}
